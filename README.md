# 100 Exercícios de JavaScript para Entrevistas Técnicas

Este repositório contém uma lista com **100 exercícios práticos de JavaScript**, inspirados em testes técnicos aplicados no mercado brasileiro.  
O objetivo é praticar algoritmos, estruturas de dados, manipulação de strings, arrays, objetos, programação assíncrona, padrões de projeto e problemas comuns em entrevistas de desenvolvedores web.

---

## Propósito do aprendizado

- **Consolidar fundamentos**: revisar conceitos-chave de JavaScript usados no dia a dia.  
- **Preparação para entrevistas**: treinar problemas semelhantes aos cobrados em processos seletivos de empresas no Brasil.  
- **Desenvolver raciocínio lógico**: aprender a resolver problemas de forma clara, eficiente e bem estruturada.  
- **Evoluir boas práticas**: usar código limpo, testes unitários e análise de complexidade (Big-O).  
- **Autonomia no estudo**: resolver sem depender da resposta pronta, focando na reflexão sobre erros e melhorias.

Cada exercício deve ser resolvido e revisado pensando em:
1. Corretude da saída (funciona em todos os casos?)  
2. Tratamento de casos limites (strings vazias, `null`, arrays grandes, etc.)  
3. Complexidade do algoritmo (eficiência)  
4. Clareza do código (legibilidade, boas práticas)  

---

## Estrutura dos exercícios

### Strings e Arrays
1. Inverter uma string ✅
2. Verificar palíndromo  
3. Contar vogais  
4. Somar números pares de um array  
5. Remover duplicatas de um array  
6. Flatten (achatamento) de array 1 nível  
7. Implementar `map` manual  
8. Implementar `filter` manual  
9. Implementar `reduce` manual  
10. Implementar `debounce`  

### Funções de Alta Ordem e Performance
11. Implementar `throttle`  
12. Implementar `memoize`  
13. Comparar objetos (shallow)  
14. Comparar objetos (deep)  
15. Clone profundo (deep clone)  
16. Flatten recursivo  
17. Implementar `Promise.all`  
18. Implementar `Promise.race`  
19. Controlar concorrência de Promises  
20. Retry com backoff exponencial  

### Validações e Algoritmos Brasileiros
21. Fetch com timeout  
22. Validar CPF  
23. Validar CNPJ  
24. Contador de frequência  
25. Interseção de arrays  
26. União de arrays  
27. Diferença de arrays  
28. Mover zeros para o final  
29. Somar dois números representados por arrays  
30. Detectar ciclo em linked list  

### Estruturas de Dados
31. Implementar Stack e Queue  
32. LRU Cache (tamanho N)  
33. Ordenação customizada (stable)  
34. Implementar quicksort  
35. Implementar mergesort  
36. Encontrar k-ésimo maior elemento  
37. Verificar anagramas  
38. Subarray com soma máxima (Kadane)  
39. Problema two-sum  
40. Encontrar pares únicos com soma X  

### DOM, Browser e Frontend
41. Rotacionar array à direita k vezes  
42. Analisar performance de código  
43. Implementar event emitter  
44. Event delegation no DOM  
45. Criar modal acessível  
46. Lazy loading de imagens  
47. Autocomplete simples  
48. Virtual scrolling  
49. Parser CSV simples  
50. Validar URL  

### Datas, Números e Internacionalização
51. Normalizar e comparar datas  
52. Formatar moeda em pt-BR  
53. Implementar `compose` / `pipe`  
54. Currying  
55. Implementar `bind` manual  
56. Implementar `call` e `apply` manuais  
57. Closures e encapsulamento  
58. Gerador de IDs únicos  
59. Throttle com opções `leading`/`trailing`  
60. Validar JSON grande (streaming)  

### Node.js e Backend
61. Criar API REST com Express  
62. Middleware de autenticação JWT  
63. Upload de arquivo com streaming  
64. Rate limiter básico  
65. Calcular checksum de arquivo  
66. CRUD com MongoDB  
67. Pub/Sub com WebSockets  
68. Service Worker: cache offline  
69. Criar CLI simples (Node.js)  
70. Testes unitários com Jest  

### Testes e Boas Práticas
71. Snapshot testing  
72. Testes assíncronos com Jest  
73. Manipular Blob/File e download  
74. Converter base64 ↔ binary  
75. Retry limitado em API pública  
76. Extrair dados de HTML  
77. Mini template engine  
78. Sanitização contra XSS  
79. Debounce em React (input controlado)  
80. Implementar hook `usePrevious`  

### Algoritmos Avançados e Casos Reais
81. Keyed list reconciliation  
82. Criar HOC simples em React  
83. Hook de resize com throttle  
84. Detectar memory leaks no browser  
85. Serializar/deserializar objetos complexos  
86. Debounce em Web Worker  
87. Operações com BigInt  
88. Criar fila de tarefas (task queue)  
89. Verificar parênteses balanceados  
90. Longest substring sem repetição  

### Desafios Extras
91. Número por extenso em pt-BR  
92. Algoritmo de compressão simples (RLE)  
93. Estratégia de reconexão WebSocket  
94. Gerar SHA256 (crypto)  
95. Cache stale-while-revalidate  
96. Implementar observer pattern (Proxy)  
97. Parser de expressões matemáticas  
98. Prevenir race conditions  
99. Scheduler com prioridades  
100. Projeto final: mini app ToDo fullstack (frontend + backend + testes)

---

## Como usar este repositório
1. Escolha um exercício.  
2. Resolva em `JavaScript` no seu estilo.  
3. Teste com casos simples e casos limites.  
4. Suba no repositório (um arquivo por exercício ou pastas organizadas).  
5. Revise a solução e compare com melhores práticas depois.  

---

## Observação
O foco **não é ter a resposta pronta**, mas **aprender com erros** e refletir sobre complexidade, clareza e corretude.  
Sempre que possível, escreva testes unitários para validar sua solução.

## @onthiagooliveira

